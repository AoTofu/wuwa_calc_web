# exporters.py

from PIL import Image, ImageDraw, ImageFont
import json
import os
from datetime import datetime
# from constants import FONT_FAMILY # GUI用なので不要
from gui_widgets import ImageHandler

class PngExporter:
    # 画像のサイズやマージンなどを定数として定義
    CARD_WIDTH = 200
    CARD_HEIGHT = 300
    PADDING = 20
    ITEM_IMG_SIZE = 64
    HARMONY_IMG_SIZE = 48
    TEXT_COLOR = (255, 255, 255)
    BG_COLOR = (30, 30, 30) # "#1E1E1E"

    # 使用するフォントファイルのパスを定義
    # プロジェクトルートに assets/fonts/ を作成し、そこにフォントファイルを配置してください
    FONT_PATH = "assets/NotoSansJP-VariableFont_wght.ttf"

    @classmethod
    def generate_build_image(cls, team_builds, username):
        """チームビルドの情報から一枚の画像を生成する"""
        if not team_builds:
            return None

        # Pillowで扱えるフォントを取得
        try:
            # 同梱したフォントファイルが存在するか確認し、直接指定して読み込む
            if os.path.exists(cls.FONT_PATH):
                title_font = ImageFont.truetype(cls.FONT_PATH, 24)
            else:
                # 存在しない場合はデフォルトフォントにフォールバック
                title_font = ImageFont.load_default()

            if os.path.exists(cls.FONT_PATH):
                text_font = ImageFont.truetype(cls.FONT_PATH, 16)
            else:
                text_font = ImageFont.load_default()

        except IOError as e:
            print(f"フォント読み込みエラー: {e}")
            print("画像内の日本語が正しく表示されない可能性があります。")
            # エラー時もデフォルトフォントを使用
            title_font = ImageFont.load_default()
            text_font = ImageFont.load_default()

        # 画像全体のサイズを計算
        num_chars = len(team_builds)
        total_width = (cls.CARD_WIDTH * num_chars) + (cls.PADDING * (num_chars + 1))
        total_height = cls.CARD_HEIGHT + (cls.PADDING * 2)

        # ベースとなる画像を作成
        base_image = Image.new("RGBA", (total_width, total_height), cls.BG_COLOR)
        draw = ImageDraw.Draw(base_image)

        for i, build in enumerate(team_builds):
            # 各キャラクターカードの描画開始位置
            start_x = cls.PADDING + i * (cls.CARD_WIDTH + cls.PADDING)
            start_y = cls.PADDING
            
            # 1. キャラクター画像
            char_img_path = cls._get_image_path("characters", build.get("character_data", {}).get("image_file"))
            cls._paste_image(base_image, char_img_path, (start_x + (cls.CARD_WIDTH - cls.ITEM_IMG_SIZE) // 2, start_y + 10), (cls.ITEM_IMG_SIZE, cls.ITEM_IMG_SIZE))
            
            # キャラクター名
            char_name = build.get("character_name", "N/A")
            draw.text((start_x + cls.CARD_WIDTH // 2, start_y + 10 + cls.ITEM_IMG_SIZE + 5), char_name, font=text_font, fill=cls.TEXT_COLOR, anchor="mt")

            # 2. 武器画像
            weapon_img_path = cls._get_image_path("weapons", build.get("weapon_data", {}).get("image_file"))
            cls._paste_image(base_image, weapon_img_path, (start_x + (cls.CARD_WIDTH - cls.ITEM_IMG_SIZE) // 2, start_y + 90), (cls.ITEM_IMG_SIZE, cls.ITEM_IMG_SIZE))

            # 3. ハーモニー効果
            harmony1_path = cls._get_image_path("harmony_effects", build.get("harmony1_data", {}).get("image_file"))
            cls._paste_image(base_image, harmony1_path, (start_x + cls.CARD_WIDTH // 2 - cls.HARMONY_IMG_SIZE - 5, start_y + 170), (cls.HARMONY_IMG_SIZE, cls.HARMONY_IMG_SIZE))

            harmony2_path = cls._get_image_path("harmony_effects", build.get("harmony2_data", {}).get("image_file"))
            cls._paste_image(base_image, harmony2_path, (start_x + cls.CARD_WIDTH // 2 + 5, start_y + 170), (cls.HARMONY_IMG_SIZE, cls.HARMONY_IMG_SIZE))

        # 4. ユーザー名と日時
        now = datetime.now().strftime("%Y-%m-%d %H:%M")
        footer_text = f"Generated by: {username} at {now}"
        draw.text((total_width - cls.PADDING, total_height - cls.PADDING), footer_text, font=text_font, fill=cls.TEXT_COLOR, anchor="rs")

        return base_image
    
    @classmethod
    def _get_image_path(cls, dtype, fname):
        """Pillowで開くための画像パスを取得する"""
        if not fname: return None
        return os.path.join("images", dtype, fname)

    @classmethod
    def _paste_image(cls, base_img, img_path, position, size):
        """画像を読み込んでベース画像に貼り付ける（アルファチャンネル対応）"""
        if not img_path or not os.path.exists(img_path): return

        try:
            img_to_paste = Image.open(img_path).convert("RGBA")
            img_to_paste.thumbnail(size, Image.Resampling.LANCZOS)
            
            # 画像がアルファチャンネルを持つ場合、それを使って貼り付け
            base_img.paste(img_to_paste, position, img_to_paste)
        except Exception as e:
            print(f"画像貼り付けエラー: {e}")

    @classmethod
    def save_with_metadata(cls, image: Image.Image, sharable_data: dict, filepath: str):
        """画像にJSONデータを埋め込んで保存する"""
        if not image: return False
        
        # PillowのPngInfoオブジェクトを使ってメタデータを設定
        from PIL import PngImagePlugin
        metadata = PngImagePlugin.PngInfo()
        
        # --- ▼▼▼ ここから修正 ▼▼▼ ---
        # setをlistに変換するカスタムJSONエンコーダーを定義
        class SetEncoder(json.JSONEncoder):
            def default(self, obj):
                if isinstance(obj, set):
                    return list(obj)
                return json.JSONEncoder.default(self, obj)
        
        # データをJSON文字列に変換する際に、カスタムエンコーダー(cls=SetEncoder)を指定
        json_string = json.dumps(sharable_data, ensure_ascii=False, cls=SetEncoder)
        # --- ▲▲▲ 修正ここまで ▲▲▲ ---
        
        # メタデータとして追加（キーは自由に設定可能）
        metadata.add_text("WutheringWavesDamageCalcData", json_string)
        
        # メタデータ付きで画像を保存
        image.save(filepath, "PNG", pnginfo=metadata)
        return True

    @classmethod
    def load_from_metadata(cls, filepath: str):
        """PNG画像からメタデータを読み込んでJSONデータを復元する"""
        try:
            with Image.open(filepath) as img:
                # メタデータキーを指定してテキストを読み込む
                json_string = img.text.get("WutheringWavesDamageCalcData")
                if json_string:
                    return json.loads(json_string)
        except Exception as e:
            print(f"メタデータ読み込みエラー: {e}")
        return None